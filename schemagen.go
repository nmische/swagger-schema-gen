// Swagger Schema Gen is a tool to automate the creation of Swagger data models (schemas).
//
package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/build"
	"go/parser"
	"go/token"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"reflect"
	"sort"
	"strings"
	"unicode"
	"unicode/utf8"
)

var (
	output     = flag.String("output", "", "output file name; if not file is given output is written to stdout")
	trimprefix = flag.String("trimprefix", "", "trim the `prefix` from the generated schema object names")
	buildTags  = flag.String("tags", "", "comma-separated list of build tags to apply")
)

// Usage is a replacement usage function for the flags package.
func Usage() {
	fmt.Fprintf(os.Stderr, "Usage of schemagen:\n")
	fmt.Fprintf(os.Stderr, "\tschemagen [flags] [directory]\n")
	fmt.Fprintf(os.Stderr, "Flags:\n")
	flag.PrintDefaults()
}

func main() {
	log.SetFlags(0)
	log.SetPrefix("schemagen: ")
	flag.Usage = Usage
	flag.Parse()

	var tags []string
	if len(*buildTags) > 0 {
		tags = strings.Split(*buildTags, ",")
	}

	// We accept either one directory or a list of files. Which do we have?
	args := flag.Args()
	if len(args) == 0 {
		// Default: process whole package in current directory.
		args = []string{"."}
	}

	// Parse the package once.
	g := Generator{
		trimPrefix: *trimprefix,
	}
	if len(args) == 1 && isDirectory(args[0]) {
		g.parsePackageDir(args[0], tags)
	} else {
		flag.Usage()
		os.Exit(2)
	}

	// Print the header and package clause.
	g.Printf("# Code generated by \"schemagen %s\"; DO NOT EDIT.\n", strings.Join(os.Args[1:], " "))
	g.Printf("\n")

	// Run generate.
	g.generate()

	// Format the output.
	yaml := g.format()

	outputName := *output

	// Write to stdout.
	if outputName == "" {
		fmt.Println(string(yaml[:]))
		return
	}

	// Write to file.
	err := ioutil.WriteFile(outputName, yaml, 0644)
	if err != nil {
		log.Fatalf("writing output: %s", err)
	}
}

// isDirectory reports whether the named file is a directory.
func isDirectory(name string) bool {
	info, err := os.Stat(name)
	if err != nil {
		log.Fatal(err)
	}
	return info.IsDir()
}

// Generator holds the state of the analysis.
type Generator struct {
	buf        bytes.Buffer       // Accumulated output.
	pkg        *Package           // Package we are scanning.
	objects    map[string]*Object // Accumulator for objects to be represented in the Swagger model.
	trimPrefix string
	currentObj *Object // The object being generated
}

func (g *Generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

// File holds a single parsed file and associated data.
type File struct {
	pkg       *Package   // Package to which this file belongs.
	file      *ast.File  // Parsed AST.
	src       []byte     // File content
	generator *Generator // Generator associated with the file
}

// Package holds pakage data.
type Package struct {
	dir   string
	name  string
	files []*File
}

func buildContext(tags []string) *build.Context {
	ctx := build.Default
	ctx.BuildTags = tags
	return &ctx
}

// parsePackageDir parses the package residing in the directory.
func (g *Generator) parsePackageDir(directory string, tags []string) {
	pkg, err := buildContext(tags).ImportDir(directory, 0)
	if err != nil {
		log.Fatalf("cannot process directory %s: %s", directory, err)
	}
	var names []string
	names = append(names, pkg.GoFiles...)
	names = prefixDirectory(directory, names)
	g.parsePackage(directory, names, nil)
}

// prefixDirectory places the directory name on the beginning of each name in the list.
func prefixDirectory(directory string, names []string) []string {
	if directory == "." {
		return names
	}
	ret := make([]string, len(names))
	for i, name := range names {
		ret[i] = filepath.Join(directory, name)
	}
	return ret
}

// parsePackage analyzes the single package constructed from the named files.
// If text is non-nil, it is a string to be used instead of the content of the file,
// to be used for testing. parsePackage exits if there is an error.
func (g *Generator) parsePackage(directory string, names []string, text interface{}) {
	var files []*File
	var astFiles []*ast.File
	g.pkg = new(Package)
	fs := token.NewFileSet()
	for _, name := range names {
		if !strings.HasSuffix(name, ".go") {
			continue
		}
		parsedFile, err := parser.ParseFile(fs, name, text, parser.ParseComments)
		if err != nil {
			log.Fatalf("parsing package: %s: %s", name, err)
		}
		content, err := ioutil.ReadFile(name)
		if err != nil {
			log.Fatalf("reading file: %s: %s", name, err)
		}
		astFiles = append(astFiles, parsedFile)
		files = append(files, &File{
			file:      parsedFile,
			src:       content,
			pkg:       g.pkg,
			generator: g,
		})
	}
	if len(astFiles) == 0 {
		log.Fatalf("%s: no buildable Go files", directory)
	}
	g.pkg.name = astFiles[0].Name.Name
	g.pkg.files = files
	g.pkg.dir = directory
}

// generate produces the intermedate representation of Swagger objects and properties
func (g *Generator) generate() {
	g.objects = make(map[string]*Object)
	for _, file := range g.pkg.files {
		// Walk the file
		if file.file != nil {
			ast.Inspect(file.file, func(n ast.Node) bool {
				if typeSpec, ok := n.(*ast.TypeSpec); ok {
					ast.Inspect(typeSpec, file.genObj)
				}
				return true
			})

		}
	}

	if len(g.objects) == 0 {
		log.Fatalf("no objects defined in package %s", g.pkg.name)
	}

}

// format outputs the YAML.
func (g *Generator) format() []byte {

	// Brute force YAML

	// Sort the object by name
	so := make([]string, 0, len(g.objects))
	for k := range g.objects {
		so = append(so, k)
	}
	sort.Strings(so)

	for _, k := range so {

		o := g.objects[k]

		indent := 0
		g.Printf("%s:\n", o.Title)
		if len(o.Refs) > 0 { // we have an embedded object
			indent = indent + 2
			g.Printf("%sallOf:\n", strings.Repeat(" ", indent))
			indent = indent + 2
			for _, e := range o.Refs {
				g.Printf("%s- $ref: %s\n", strings.Repeat(" ", indent), e.GetRef())
			}
			indent = indent - 2
		}
		if len(o.Properties) > 0 { // we have properties

			if len(o.Refs) > 0 {
				indent = indent + 2
				g.Printf("%s- type: object\n", strings.Repeat(" ", indent))
				g.Printf("%s  properties:\n", strings.Repeat(" ", indent))
				indent = indent + 2
			} else {
				indent = indent + 2
				g.Printf("%stype: object\n", strings.Repeat(" ", indent))
				g.Printf("%sproperties:\n", strings.Repeat(" ", indent))
			}
			indent = indent + 2
			for _, p := range o.Properties {

				g.Printf("%s%s:\n", strings.Repeat(" ", indent), p.Title)
				if p.Ref != "" {
					indent = indent + 2
					g.Printf("%s$ref: %s\n", strings.Repeat(" ", indent), p.Ref)
					indent = indent - 2
					continue
				}
				if p.Type != "" {
					indent = indent + 2
					g.Printf("%stype: %s\n", strings.Repeat(" ", indent), p.Type)
					indent = indent - 2
					continue
				}
			}
			indent = indent - 2
		}

	}

	return g.buf.Bytes()
}

// genObj processes one type spec.
func (f *File) genObj(n ast.Node) bool {

	g := f.generator
	var offset token.Pos

	switch node := n.(type) {

	case *ast.TypeSpec:

		offset = n.Pos()

		ot := node.Name.Name

		if o, ok := g.objects[ot]; ok {
			// We have seen this type before
			g.currentObj = o
		} else {
			// This is a new type
			o := &Object{
				Title: ot,
			}
			g.objects[ot] = o
			g.currentObj = o
		}

		return true

	case *ast.Field:

		// If we have a name this field is not an embedded type
		if node.Names != nil {

			// Get the property name
			pn := lowerFirst(node.Names[0].Name)
			// We have name, but check to see if we have a json we can use instead
			if node.Tag != nil {
				t := node.Tag.Value
				tag := reflect.StructTag(t[1 : len(t)-1])
				j := tag.Get("json")
				for _, i := range strings.Split(j, ",") {
					if i != "omitempty" {
						pn = i
					}
				}
			}

			p := &Property{
				Title: pn,
			}

			// Get the type

			tn := string(f.src[node.Type.Pos()-offset-1 : node.Type.End()-(offset)])
			tn = strings.TrimSpace(tn)

			switch {
			case strings.HasPrefix(tn, "[]"):
				p.Type = "array"
				switch ot := tn[2:]; ot {
				case "int":
					p.Items = "integer"
				case "string":
					p.Items = "string"
				default:
					// Assume it is a type
					ao := &Object{}
					if o, ok := g.objects[ot]; ok {
						// We have seen this type before
						ao = o
					} else {
						// This is a new type
						ao.Title = ot
						g.objects[ot] = ao
					}
					p.Items = ao.GetRef()

				}

			case tn == "int":
				p.Type = "integer"

			case tn == "string":
				p.Type = "string"

			default:
				// Assume it is a type
				ro := &Object{}
				if o, ok := g.objects[tn]; ok {
					// We have seen this type before
					ro = o
				} else {
					// This is a new type
					ro.Title = tn
					g.objects[tn] = ro
				}
				p.Ref = ro.GetRef()

			}
			g.currentObj.Properties = append(g.currentObj.Properties, p)

		}

		// If we don't have a name this field is an embedded type
		if node.Names == nil {

			tn := string(f.src[node.Type.Pos()-offset-1 : node.Type.End()-(offset)])
			tn = strings.TrimSpace(tn)
			ro := &Object{}
			if o, ok := g.objects[tn]; ok {
				// We have seen this type before
				ro = o
			} else {
				// This is a new type
				ro.Title = tn
				g.objects[tn] = ro
			}

			g.currentObj.Refs = append(g.currentObj.Refs, ro)

		}

	}

	// We don't care about other node types
	return true
}

// Object represents a Swagger schema object
type Object struct {
	Title      string
	Refs       []*Object
	Properties []*Property
}

// GetRef returns the Swagger reference to to the object
func (o *Object) GetRef() string {
	return "'#/components/schemas/" + o.Title + "'"
}

// Property represents a Swagger schema object property
type Property struct {
	Title     string
	Type      string
	Min       int
	Max       int
	MinLength int
	MaxLength int
	Format    string
	Pattern   string
	Nullable  bool
	Items     string
	Ref       string
}

// Helpers

func lowerFirst(s string) string {
	if s == "" {
		return ""
	}
	r, n := utf8.DecodeRuneInString(s)
	return string(unicode.ToLower(r)) + s[n:]
}
